// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	http "net/http"
	sync "sync"

	provider "github.com/IBM/ibmcloud-storage-volume-lib/lib/provider"
)

type FakeSession struct {
	AttachVolumeStub        func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)
	attachVolumeMutex       sync.RWMutex
	attachVolumeArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	attachVolumeReturns struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	attachVolumeReturnsOnCall map[int]struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	AuthorizeVolumeStub        func(provider.VolumeAuthorization) error
	authorizeVolumeMutex       sync.RWMutex
	authorizeVolumeArgsForCall []struct {
		arg1 provider.VolumeAuthorization
	}
	authorizeVolumeReturns struct {
		result1 error
	}
	authorizeVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	CreateSnapshotStub        func(*provider.Volume, map[string]string) (*provider.Snapshot, error)
	createSnapshotMutex       sync.RWMutex
	createSnapshotArgsForCall []struct {
		arg1 *provider.Volume
		arg2 map[string]string
	}
	createSnapshotReturns struct {
		result1 *provider.Snapshot
		result2 error
	}
	createSnapshotReturnsOnCall map[int]struct {
		result1 *provider.Snapshot
		result2 error
	}
	CreateVolumeStub        func(provider.Volume) (*provider.Volume, error)
	createVolumeMutex       sync.RWMutex
	createVolumeArgsForCall []struct {
		arg1 provider.Volume
	}
	createVolumeReturns struct {
		result1 *provider.Volume
		result2 error
	}
	createVolumeReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	CreateVolumeFromSnapshotStub        func(provider.Snapshot, map[string]string) (*provider.Volume, error)
	createVolumeFromSnapshotMutex       sync.RWMutex
	createVolumeFromSnapshotArgsForCall []struct {
		arg1 provider.Snapshot
		arg2 map[string]string
	}
	createVolumeFromSnapshotReturns struct {
		result1 *provider.Volume
		result2 error
	}
	createVolumeFromSnapshotReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	DeleteSnapshotStub        func(*provider.Snapshot) error
	deleteSnapshotMutex       sync.RWMutex
	deleteSnapshotArgsForCall []struct {
		arg1 *provider.Snapshot
	}
	deleteSnapshotReturns struct {
		result1 error
	}
	deleteSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVolumeStub        func(*provider.Volume) error
	deleteVolumeMutex       sync.RWMutex
	deleteVolumeArgsForCall []struct {
		arg1 *provider.Volume
	}
	deleteVolumeReturns struct {
		result1 error
	}
	deleteVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	DetachVolumeStub        func(provider.VolumeAttachmentRequest) (*http.Response, error)
	detachVolumeMutex       sync.RWMutex
	detachVolumeArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	detachVolumeReturns struct {
		result1 *http.Response
		result2 error
	}
	detachVolumeReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	GetProviderDisplayNameStub        func() provider.VolumeProvider
	getProviderDisplayNameMutex       sync.RWMutex
	getProviderDisplayNameArgsForCall []struct {
	}
	getProviderDisplayNameReturns struct {
		result1 provider.VolumeProvider
	}
	getProviderDisplayNameReturnsOnCall map[int]struct {
		result1 provider.VolumeProvider
	}
	GetSnapshotStub        func(string) (*provider.Snapshot, error)
	getSnapshotMutex       sync.RWMutex
	getSnapshotArgsForCall []struct {
		arg1 string
	}
	getSnapshotReturns struct {
		result1 *provider.Snapshot
		result2 error
	}
	getSnapshotReturnsOnCall map[int]struct {
		result1 *provider.Snapshot
		result2 error
	}
	GetSnapshotWithVolumeIDStub        func(string, string) (*provider.Snapshot, error)
	getSnapshotWithVolumeIDMutex       sync.RWMutex
	getSnapshotWithVolumeIDArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getSnapshotWithVolumeIDReturns struct {
		result1 *provider.Snapshot
		result2 error
	}
	getSnapshotWithVolumeIDReturnsOnCall map[int]struct {
		result1 *provider.Snapshot
		result2 error
	}
	GetVolumeStub        func(string) (*provider.Volume, error)
	getVolumeMutex       sync.RWMutex
	getVolumeArgsForCall []struct {
		arg1 string
	}
	getVolumeReturns struct {
		result1 *provider.Volume
		result2 error
	}
	getVolumeReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	GetVolumeAttachmentStub        func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)
	getVolumeAttachmentMutex       sync.RWMutex
	getVolumeAttachmentArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	getVolumeAttachmentReturns struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	getVolumeAttachmentReturnsOnCall map[int]struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	GetVolumeByNameStub        func(string) (*provider.Volume, error)
	getVolumeByNameMutex       sync.RWMutex
	getVolumeByNameArgsForCall []struct {
		arg1 string
	}
	getVolumeByNameReturns struct {
		result1 *provider.Volume
		result2 error
	}
	getVolumeByNameReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	GetVolumeByRequestIDStub        func(string) (*provider.Volume, error)
	getVolumeByRequestIDMutex       sync.RWMutex
	getVolumeByRequestIDArgsForCall []struct {
		arg1 string
	}
	getVolumeByRequestIDReturns struct {
		result1 *provider.Volume
		result2 error
	}
	getVolumeByRequestIDReturnsOnCall map[int]struct {
		result1 *provider.Volume
		result2 error
	}
	ListAllSnapshotsStub        func(string) ([]*provider.Snapshot, error)
	listAllSnapshotsMutex       sync.RWMutex
	listAllSnapshotsArgsForCall []struct {
		arg1 string
	}
	listAllSnapshotsReturns struct {
		result1 []*provider.Snapshot
		result2 error
	}
	listAllSnapshotsReturnsOnCall map[int]struct {
		result1 []*provider.Snapshot
		result2 error
	}
	ListSnapshotsStub        func() ([]*provider.Snapshot, error)
	listSnapshotsMutex       sync.RWMutex
	listSnapshotsArgsForCall []struct {
	}
	listSnapshotsReturns struct {
		result1 []*provider.Snapshot
		result2 error
	}
	listSnapshotsReturnsOnCall map[int]struct {
		result1 []*provider.Snapshot
		result2 error
	}
	ListVolumesStub        func(int64, string, map[string]string) (*provider.VolumeList, error)
	listVolumesMutex       sync.RWMutex
	listVolumesArgsForCall []struct {
		arg1 int64
		arg2 string
		arg3 map[string]string
	}
	listVolumesReturns struct {
		result1 *provider.VolumeList
		result2 error
	}
	listVolumesReturnsOnCall map[int]struct {
		result1 *provider.VolumeList
		result2 error
	}
	OrderSnapshotStub        func(provider.Volume) error
	orderSnapshotMutex       sync.RWMutex
	orderSnapshotArgsForCall []struct {
		arg1 provider.Volume
	}
	orderSnapshotReturns struct {
		result1 error
	}
	orderSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	ProviderNameStub        func() provider.VolumeProvider
	providerNameMutex       sync.RWMutex
	providerNameArgsForCall []struct {
	}
	providerNameReturns struct {
		result1 provider.VolumeProvider
	}
	providerNameReturnsOnCall map[int]struct {
		result1 provider.VolumeProvider
	}
	TypeStub        func() provider.VolumeType
	typeMutex       sync.RWMutex
	typeArgsForCall []struct {
	}
	typeReturns struct {
		result1 provider.VolumeType
	}
	typeReturnsOnCall map[int]struct {
		result1 provider.VolumeType
	}
	UpdateVolumeStub        func(provider.Volume) error
	updateVolumeMutex       sync.RWMutex
	updateVolumeArgsForCall []struct {
		arg1 provider.Volume
	}
	updateVolumeReturns struct {
		result1 error
	}
	updateVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForAttachVolumeStub        func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)
	waitForAttachVolumeMutex       sync.RWMutex
	waitForAttachVolumeArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	waitForAttachVolumeReturns struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	waitForAttachVolumeReturnsOnCall map[int]struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}
	WaitForDetachVolumeStub        func(provider.VolumeAttachmentRequest) error
	waitForDetachVolumeMutex       sync.RWMutex
	waitForDetachVolumeArgsForCall []struct {
		arg1 provider.VolumeAttachmentRequest
	}
	waitForDetachVolumeReturns struct {
		result1 error
	}
	waitForDetachVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSession) AttachVolume(arg1 provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) {
	fake.attachVolumeMutex.Lock()
	ret, specificReturn := fake.attachVolumeReturnsOnCall[len(fake.attachVolumeArgsForCall)]
	fake.attachVolumeArgsForCall = append(fake.attachVolumeArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	fake.recordInvocation("AttachVolume", []interface{}{arg1})
	fake.attachVolumeMutex.Unlock()
	if fake.AttachVolumeStub != nil {
		return fake.AttachVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.attachVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) AttachVolumeCallCount() int {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	return len(fake.attachVolumeArgsForCall)
}

func (fake *FakeSession) AttachVolumeCalls(stub func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = stub
}

func (fake *FakeSession) AttachVolumeArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	argsForCall := fake.attachVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) AttachVolumeReturns(result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	fake.attachVolumeReturns = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) AttachVolumeReturnsOnCall(i int, result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	if fake.attachVolumeReturnsOnCall == nil {
		fake.attachVolumeReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAttachmentResponse
			result2 error
		})
	}
	fake.attachVolumeReturnsOnCall[i] = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) AuthorizeVolume(arg1 provider.VolumeAuthorization) error {
	fake.authorizeVolumeMutex.Lock()
	ret, specificReturn := fake.authorizeVolumeReturnsOnCall[len(fake.authorizeVolumeArgsForCall)]
	fake.authorizeVolumeArgsForCall = append(fake.authorizeVolumeArgsForCall, struct {
		arg1 provider.VolumeAuthorization
	}{arg1})
	fake.recordInvocation("AuthorizeVolume", []interface{}{arg1})
	fake.authorizeVolumeMutex.Unlock()
	if fake.AuthorizeVolumeStub != nil {
		return fake.AuthorizeVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.authorizeVolumeReturns
	return fakeReturns.result1
}

func (fake *FakeSession) AuthorizeVolumeCallCount() int {
	fake.authorizeVolumeMutex.RLock()
	defer fake.authorizeVolumeMutex.RUnlock()
	return len(fake.authorizeVolumeArgsForCall)
}

func (fake *FakeSession) AuthorizeVolumeCalls(stub func(provider.VolumeAuthorization) error) {
	fake.authorizeVolumeMutex.Lock()
	defer fake.authorizeVolumeMutex.Unlock()
	fake.AuthorizeVolumeStub = stub
}

func (fake *FakeSession) AuthorizeVolumeArgsForCall(i int) provider.VolumeAuthorization {
	fake.authorizeVolumeMutex.RLock()
	defer fake.authorizeVolumeMutex.RUnlock()
	argsForCall := fake.authorizeVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) AuthorizeVolumeReturns(result1 error) {
	fake.authorizeVolumeMutex.Lock()
	defer fake.authorizeVolumeMutex.Unlock()
	fake.AuthorizeVolumeStub = nil
	fake.authorizeVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) AuthorizeVolumeReturnsOnCall(i int, result1 error) {
	fake.authorizeVolumeMutex.Lock()
	defer fake.authorizeVolumeMutex.Unlock()
	fake.AuthorizeVolumeStub = nil
	if fake.authorizeVolumeReturnsOnCall == nil {
		fake.authorizeVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.authorizeVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeSession) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeSession) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeSession) CreateSnapshot(arg1 *provider.Volume, arg2 map[string]string) (*provider.Snapshot, error) {
	fake.createSnapshotMutex.Lock()
	ret, specificReturn := fake.createSnapshotReturnsOnCall[len(fake.createSnapshotArgsForCall)]
	fake.createSnapshotArgsForCall = append(fake.createSnapshotArgsForCall, struct {
		arg1 *provider.Volume
		arg2 map[string]string
	}{arg1, arg2})
	fake.recordInvocation("CreateSnapshot", []interface{}{arg1, arg2})
	fake.createSnapshotMutex.Unlock()
	if fake.CreateSnapshotStub != nil {
		return fake.CreateSnapshotStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createSnapshotReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) CreateSnapshotCallCount() int {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	return len(fake.createSnapshotArgsForCall)
}

func (fake *FakeSession) CreateSnapshotCalls(stub func(*provider.Volume, map[string]string) (*provider.Snapshot, error)) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = stub
}

func (fake *FakeSession) CreateSnapshotArgsForCall(i int) (*provider.Volume, map[string]string) {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	argsForCall := fake.createSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSession) CreateSnapshotReturns(result1 *provider.Snapshot, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	fake.createSnapshotReturns = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateSnapshotReturnsOnCall(i int, result1 *provider.Snapshot, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	if fake.createSnapshotReturnsOnCall == nil {
		fake.createSnapshotReturnsOnCall = make(map[int]struct {
			result1 *provider.Snapshot
			result2 error
		})
	}
	fake.createSnapshotReturnsOnCall[i] = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolume(arg1 provider.Volume) (*provider.Volume, error) {
	fake.createVolumeMutex.Lock()
	ret, specificReturn := fake.createVolumeReturnsOnCall[len(fake.createVolumeArgsForCall)]
	fake.createVolumeArgsForCall = append(fake.createVolumeArgsForCall, struct {
		arg1 provider.Volume
	}{arg1})
	fake.recordInvocation("CreateVolume", []interface{}{arg1})
	fake.createVolumeMutex.Unlock()
	if fake.CreateVolumeStub != nil {
		return fake.CreateVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) CreateVolumeCallCount() int {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	return len(fake.createVolumeArgsForCall)
}

func (fake *FakeSession) CreateVolumeCalls(stub func(provider.Volume) (*provider.Volume, error)) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = stub
}

func (fake *FakeSession) CreateVolumeArgsForCall(i int) provider.Volume {
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	argsForCall := fake.createVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) CreateVolumeReturns(result1 *provider.Volume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	fake.createVolumeReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolumeReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.createVolumeMutex.Lock()
	defer fake.createVolumeMutex.Unlock()
	fake.CreateVolumeStub = nil
	if fake.createVolumeReturnsOnCall == nil {
		fake.createVolumeReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.createVolumeReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolumeFromSnapshot(arg1 provider.Snapshot, arg2 map[string]string) (*provider.Volume, error) {
	fake.createVolumeFromSnapshotMutex.Lock()
	ret, specificReturn := fake.createVolumeFromSnapshotReturnsOnCall[len(fake.createVolumeFromSnapshotArgsForCall)]
	fake.createVolumeFromSnapshotArgsForCall = append(fake.createVolumeFromSnapshotArgsForCall, struct {
		arg1 provider.Snapshot
		arg2 map[string]string
	}{arg1, arg2})
	fake.recordInvocation("CreateVolumeFromSnapshot", []interface{}{arg1, arg2})
	fake.createVolumeFromSnapshotMutex.Unlock()
	if fake.CreateVolumeFromSnapshotStub != nil {
		return fake.CreateVolumeFromSnapshotStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createVolumeFromSnapshotReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) CreateVolumeFromSnapshotCallCount() int {
	fake.createVolumeFromSnapshotMutex.RLock()
	defer fake.createVolumeFromSnapshotMutex.RUnlock()
	return len(fake.createVolumeFromSnapshotArgsForCall)
}

func (fake *FakeSession) CreateVolumeFromSnapshotCalls(stub func(provider.Snapshot, map[string]string) (*provider.Volume, error)) {
	fake.createVolumeFromSnapshotMutex.Lock()
	defer fake.createVolumeFromSnapshotMutex.Unlock()
	fake.CreateVolumeFromSnapshotStub = stub
}

func (fake *FakeSession) CreateVolumeFromSnapshotArgsForCall(i int) (provider.Snapshot, map[string]string) {
	fake.createVolumeFromSnapshotMutex.RLock()
	defer fake.createVolumeFromSnapshotMutex.RUnlock()
	argsForCall := fake.createVolumeFromSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSession) CreateVolumeFromSnapshotReturns(result1 *provider.Volume, result2 error) {
	fake.createVolumeFromSnapshotMutex.Lock()
	defer fake.createVolumeFromSnapshotMutex.Unlock()
	fake.CreateVolumeFromSnapshotStub = nil
	fake.createVolumeFromSnapshotReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) CreateVolumeFromSnapshotReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.createVolumeFromSnapshotMutex.Lock()
	defer fake.createVolumeFromSnapshotMutex.Unlock()
	fake.CreateVolumeFromSnapshotStub = nil
	if fake.createVolumeFromSnapshotReturnsOnCall == nil {
		fake.createVolumeFromSnapshotReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.createVolumeFromSnapshotReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) DeleteSnapshot(arg1 *provider.Snapshot) error {
	fake.deleteSnapshotMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotReturnsOnCall[len(fake.deleteSnapshotArgsForCall)]
	fake.deleteSnapshotArgsForCall = append(fake.deleteSnapshotArgsForCall, struct {
		arg1 *provider.Snapshot
	}{arg1})
	fake.recordInvocation("DeleteSnapshot", []interface{}{arg1})
	fake.deleteSnapshotMutex.Unlock()
	if fake.DeleteSnapshotStub != nil {
		return fake.DeleteSnapshotStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteSnapshotReturns
	return fakeReturns.result1
}

func (fake *FakeSession) DeleteSnapshotCallCount() int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return len(fake.deleteSnapshotArgsForCall)
}

func (fake *FakeSession) DeleteSnapshotCalls(stub func(*provider.Snapshot) error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = stub
}

func (fake *FakeSession) DeleteSnapshotArgsForCall(i int) *provider.Snapshot {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	argsForCall := fake.deleteSnapshotArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) DeleteSnapshotReturns(result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	fake.deleteSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) DeleteSnapshotReturnsOnCall(i int, result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	if fake.deleteSnapshotReturnsOnCall == nil {
		fake.deleteSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) DeleteVolume(arg1 *provider.Volume) error {
	fake.deleteVolumeMutex.Lock()
	ret, specificReturn := fake.deleteVolumeReturnsOnCall[len(fake.deleteVolumeArgsForCall)]
	fake.deleteVolumeArgsForCall = append(fake.deleteVolumeArgsForCall, struct {
		arg1 *provider.Volume
	}{arg1})
	fake.recordInvocation("DeleteVolume", []interface{}{arg1})
	fake.deleteVolumeMutex.Unlock()
	if fake.DeleteVolumeStub != nil {
		return fake.DeleteVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteVolumeReturns
	return fakeReturns.result1
}

func (fake *FakeSession) DeleteVolumeCallCount() int {
	fake.deleteVolumeMutex.RLock()
	defer fake.deleteVolumeMutex.RUnlock()
	return len(fake.deleteVolumeArgsForCall)
}

func (fake *FakeSession) DeleteVolumeCalls(stub func(*provider.Volume) error) {
	fake.deleteVolumeMutex.Lock()
	defer fake.deleteVolumeMutex.Unlock()
	fake.DeleteVolumeStub = stub
}

func (fake *FakeSession) DeleteVolumeArgsForCall(i int) *provider.Volume {
	fake.deleteVolumeMutex.RLock()
	defer fake.deleteVolumeMutex.RUnlock()
	argsForCall := fake.deleteVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) DeleteVolumeReturns(result1 error) {
	fake.deleteVolumeMutex.Lock()
	defer fake.deleteVolumeMutex.Unlock()
	fake.DeleteVolumeStub = nil
	fake.deleteVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) DeleteVolumeReturnsOnCall(i int, result1 error) {
	fake.deleteVolumeMutex.Lock()
	defer fake.deleteVolumeMutex.Unlock()
	fake.DeleteVolumeStub = nil
	if fake.deleteVolumeReturnsOnCall == nil {
		fake.deleteVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) DetachVolume(arg1 provider.VolumeAttachmentRequest) (*http.Response, error) {
	fake.detachVolumeMutex.Lock()
	ret, specificReturn := fake.detachVolumeReturnsOnCall[len(fake.detachVolumeArgsForCall)]
	fake.detachVolumeArgsForCall = append(fake.detachVolumeArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	fake.recordInvocation("DetachVolume", []interface{}{arg1})
	fake.detachVolumeMutex.Unlock()
	if fake.DetachVolumeStub != nil {
		return fake.DetachVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.detachVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) DetachVolumeCallCount() int {
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	return len(fake.detachVolumeArgsForCall)
}

func (fake *FakeSession) DetachVolumeCalls(stub func(provider.VolumeAttachmentRequest) (*http.Response, error)) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = stub
}

func (fake *FakeSession) DetachVolumeArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	argsForCall := fake.detachVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) DetachVolumeReturns(result1 *http.Response, result2 error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = nil
	fake.detachVolumeReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) DetachVolumeReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.detachVolumeMutex.Lock()
	defer fake.detachVolumeMutex.Unlock()
	fake.DetachVolumeStub = nil
	if fake.detachVolumeReturnsOnCall == nil {
		fake.detachVolumeReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.detachVolumeReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetProviderDisplayName() provider.VolumeProvider {
	fake.getProviderDisplayNameMutex.Lock()
	ret, specificReturn := fake.getProviderDisplayNameReturnsOnCall[len(fake.getProviderDisplayNameArgsForCall)]
	fake.getProviderDisplayNameArgsForCall = append(fake.getProviderDisplayNameArgsForCall, struct {
	}{})
	fake.recordInvocation("GetProviderDisplayName", []interface{}{})
	fake.getProviderDisplayNameMutex.Unlock()
	if fake.GetProviderDisplayNameStub != nil {
		return fake.GetProviderDisplayNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getProviderDisplayNameReturns
	return fakeReturns.result1
}

func (fake *FakeSession) GetProviderDisplayNameCallCount() int {
	fake.getProviderDisplayNameMutex.RLock()
	defer fake.getProviderDisplayNameMutex.RUnlock()
	return len(fake.getProviderDisplayNameArgsForCall)
}

func (fake *FakeSession) GetProviderDisplayNameCalls(stub func() provider.VolumeProvider) {
	fake.getProviderDisplayNameMutex.Lock()
	defer fake.getProviderDisplayNameMutex.Unlock()
	fake.GetProviderDisplayNameStub = stub
}

func (fake *FakeSession) GetProviderDisplayNameReturns(result1 provider.VolumeProvider) {
	fake.getProviderDisplayNameMutex.Lock()
	defer fake.getProviderDisplayNameMutex.Unlock()
	fake.GetProviderDisplayNameStub = nil
	fake.getProviderDisplayNameReturns = struct {
		result1 provider.VolumeProvider
	}{result1}
}

func (fake *FakeSession) GetProviderDisplayNameReturnsOnCall(i int, result1 provider.VolumeProvider) {
	fake.getProviderDisplayNameMutex.Lock()
	defer fake.getProviderDisplayNameMutex.Unlock()
	fake.GetProviderDisplayNameStub = nil
	if fake.getProviderDisplayNameReturnsOnCall == nil {
		fake.getProviderDisplayNameReturnsOnCall = make(map[int]struct {
			result1 provider.VolumeProvider
		})
	}
	fake.getProviderDisplayNameReturnsOnCall[i] = struct {
		result1 provider.VolumeProvider
	}{result1}
}

func (fake *FakeSession) GetSnapshot(arg1 string) (*provider.Snapshot, error) {
	fake.getSnapshotMutex.Lock()
	ret, specificReturn := fake.getSnapshotReturnsOnCall[len(fake.getSnapshotArgsForCall)]
	fake.getSnapshotArgsForCall = append(fake.getSnapshotArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetSnapshot", []interface{}{arg1})
	fake.getSnapshotMutex.Unlock()
	if fake.GetSnapshotStub != nil {
		return fake.GetSnapshotStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSnapshotReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetSnapshotCallCount() int {
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	return len(fake.getSnapshotArgsForCall)
}

func (fake *FakeSession) GetSnapshotCalls(stub func(string) (*provider.Snapshot, error)) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = stub
}

func (fake *FakeSession) GetSnapshotArgsForCall(i int) string {
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	argsForCall := fake.getSnapshotArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetSnapshotReturns(result1 *provider.Snapshot, result2 error) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = nil
	fake.getSnapshotReturns = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetSnapshotReturnsOnCall(i int, result1 *provider.Snapshot, result2 error) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = nil
	if fake.getSnapshotReturnsOnCall == nil {
		fake.getSnapshotReturnsOnCall = make(map[int]struct {
			result1 *provider.Snapshot
			result2 error
		})
	}
	fake.getSnapshotReturnsOnCall[i] = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetSnapshotWithVolumeID(arg1 string, arg2 string) (*provider.Snapshot, error) {
	fake.getSnapshotWithVolumeIDMutex.Lock()
	ret, specificReturn := fake.getSnapshotWithVolumeIDReturnsOnCall[len(fake.getSnapshotWithVolumeIDArgsForCall)]
	fake.getSnapshotWithVolumeIDArgsForCall = append(fake.getSnapshotWithVolumeIDArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetSnapshotWithVolumeID", []interface{}{arg1, arg2})
	fake.getSnapshotWithVolumeIDMutex.Unlock()
	if fake.GetSnapshotWithVolumeIDStub != nil {
		return fake.GetSnapshotWithVolumeIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSnapshotWithVolumeIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetSnapshotWithVolumeIDCallCount() int {
	fake.getSnapshotWithVolumeIDMutex.RLock()
	defer fake.getSnapshotWithVolumeIDMutex.RUnlock()
	return len(fake.getSnapshotWithVolumeIDArgsForCall)
}

func (fake *FakeSession) GetSnapshotWithVolumeIDCalls(stub func(string, string) (*provider.Snapshot, error)) {
	fake.getSnapshotWithVolumeIDMutex.Lock()
	defer fake.getSnapshotWithVolumeIDMutex.Unlock()
	fake.GetSnapshotWithVolumeIDStub = stub
}

func (fake *FakeSession) GetSnapshotWithVolumeIDArgsForCall(i int) (string, string) {
	fake.getSnapshotWithVolumeIDMutex.RLock()
	defer fake.getSnapshotWithVolumeIDMutex.RUnlock()
	argsForCall := fake.getSnapshotWithVolumeIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSession) GetSnapshotWithVolumeIDReturns(result1 *provider.Snapshot, result2 error) {
	fake.getSnapshotWithVolumeIDMutex.Lock()
	defer fake.getSnapshotWithVolumeIDMutex.Unlock()
	fake.GetSnapshotWithVolumeIDStub = nil
	fake.getSnapshotWithVolumeIDReturns = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetSnapshotWithVolumeIDReturnsOnCall(i int, result1 *provider.Snapshot, result2 error) {
	fake.getSnapshotWithVolumeIDMutex.Lock()
	defer fake.getSnapshotWithVolumeIDMutex.Unlock()
	fake.GetSnapshotWithVolumeIDStub = nil
	if fake.getSnapshotWithVolumeIDReturnsOnCall == nil {
		fake.getSnapshotWithVolumeIDReturnsOnCall = make(map[int]struct {
			result1 *provider.Snapshot
			result2 error
		})
	}
	fake.getSnapshotWithVolumeIDReturnsOnCall[i] = struct {
		result1 *provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolume(arg1 string) (*provider.Volume, error) {
	fake.getVolumeMutex.Lock()
	ret, specificReturn := fake.getVolumeReturnsOnCall[len(fake.getVolumeArgsForCall)]
	fake.getVolumeArgsForCall = append(fake.getVolumeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetVolume", []interface{}{arg1})
	fake.getVolumeMutex.Unlock()
	if fake.GetVolumeStub != nil {
		return fake.GetVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeCallCount() int {
	fake.getVolumeMutex.RLock()
	defer fake.getVolumeMutex.RUnlock()
	return len(fake.getVolumeArgsForCall)
}

func (fake *FakeSession) GetVolumeCalls(stub func(string) (*provider.Volume, error)) {
	fake.getVolumeMutex.Lock()
	defer fake.getVolumeMutex.Unlock()
	fake.GetVolumeStub = stub
}

func (fake *FakeSession) GetVolumeArgsForCall(i int) string {
	fake.getVolumeMutex.RLock()
	defer fake.getVolumeMutex.RUnlock()
	argsForCall := fake.getVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeReturns(result1 *provider.Volume, result2 error) {
	fake.getVolumeMutex.Lock()
	defer fake.getVolumeMutex.Unlock()
	fake.GetVolumeStub = nil
	fake.getVolumeReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.getVolumeMutex.Lock()
	defer fake.getVolumeMutex.Unlock()
	fake.GetVolumeStub = nil
	if fake.getVolumeReturnsOnCall == nil {
		fake.getVolumeReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.getVolumeReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeAttachment(arg1 provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) {
	fake.getVolumeAttachmentMutex.Lock()
	ret, specificReturn := fake.getVolumeAttachmentReturnsOnCall[len(fake.getVolumeAttachmentArgsForCall)]
	fake.getVolumeAttachmentArgsForCall = append(fake.getVolumeAttachmentArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	fake.recordInvocation("GetVolumeAttachment", []interface{}{arg1})
	fake.getVolumeAttachmentMutex.Unlock()
	if fake.GetVolumeAttachmentStub != nil {
		return fake.GetVolumeAttachmentStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeAttachmentReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeAttachmentCallCount() int {
	fake.getVolumeAttachmentMutex.RLock()
	defer fake.getVolumeAttachmentMutex.RUnlock()
	return len(fake.getVolumeAttachmentArgsForCall)
}

func (fake *FakeSession) GetVolumeAttachmentCalls(stub func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)) {
	fake.getVolumeAttachmentMutex.Lock()
	defer fake.getVolumeAttachmentMutex.Unlock()
	fake.GetVolumeAttachmentStub = stub
}

func (fake *FakeSession) GetVolumeAttachmentArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.getVolumeAttachmentMutex.RLock()
	defer fake.getVolumeAttachmentMutex.RUnlock()
	argsForCall := fake.getVolumeAttachmentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeAttachmentReturns(result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.getVolumeAttachmentMutex.Lock()
	defer fake.getVolumeAttachmentMutex.Unlock()
	fake.GetVolumeAttachmentStub = nil
	fake.getVolumeAttachmentReturns = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeAttachmentReturnsOnCall(i int, result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.getVolumeAttachmentMutex.Lock()
	defer fake.getVolumeAttachmentMutex.Unlock()
	fake.GetVolumeAttachmentStub = nil
	if fake.getVolumeAttachmentReturnsOnCall == nil {
		fake.getVolumeAttachmentReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAttachmentResponse
			result2 error
		})
	}
	fake.getVolumeAttachmentReturnsOnCall[i] = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeByName(arg1 string) (*provider.Volume, error) {
	fake.getVolumeByNameMutex.Lock()
	ret, specificReturn := fake.getVolumeByNameReturnsOnCall[len(fake.getVolumeByNameArgsForCall)]
	fake.getVolumeByNameArgsForCall = append(fake.getVolumeByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetVolumeByName", []interface{}{arg1})
	fake.getVolumeByNameMutex.Unlock()
	if fake.GetVolumeByNameStub != nil {
		return fake.GetVolumeByNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeByNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeByNameCallCount() int {
	fake.getVolumeByNameMutex.RLock()
	defer fake.getVolumeByNameMutex.RUnlock()
	return len(fake.getVolumeByNameArgsForCall)
}

func (fake *FakeSession) GetVolumeByNameCalls(stub func(string) (*provider.Volume, error)) {
	fake.getVolumeByNameMutex.Lock()
	defer fake.getVolumeByNameMutex.Unlock()
	fake.GetVolumeByNameStub = stub
}

func (fake *FakeSession) GetVolumeByNameArgsForCall(i int) string {
	fake.getVolumeByNameMutex.RLock()
	defer fake.getVolumeByNameMutex.RUnlock()
	argsForCall := fake.getVolumeByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeByNameReturns(result1 *provider.Volume, result2 error) {
	fake.getVolumeByNameMutex.Lock()
	defer fake.getVolumeByNameMutex.Unlock()
	fake.GetVolumeByNameStub = nil
	fake.getVolumeByNameReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeByNameReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.getVolumeByNameMutex.Lock()
	defer fake.getVolumeByNameMutex.Unlock()
	fake.GetVolumeByNameStub = nil
	if fake.getVolumeByNameReturnsOnCall == nil {
		fake.getVolumeByNameReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.getVolumeByNameReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeByRequestID(arg1 string) (*provider.Volume, error) {
	fake.getVolumeByRequestIDMutex.Lock()
	ret, specificReturn := fake.getVolumeByRequestIDReturnsOnCall[len(fake.getVolumeByRequestIDArgsForCall)]
	fake.getVolumeByRequestIDArgsForCall = append(fake.getVolumeByRequestIDArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetVolumeByRequestID", []interface{}{arg1})
	fake.getVolumeByRequestIDMutex.Unlock()
	if fake.GetVolumeByRequestIDStub != nil {
		return fake.GetVolumeByRequestIDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVolumeByRequestIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) GetVolumeByRequestIDCallCount() int {
	fake.getVolumeByRequestIDMutex.RLock()
	defer fake.getVolumeByRequestIDMutex.RUnlock()
	return len(fake.getVolumeByRequestIDArgsForCall)
}

func (fake *FakeSession) GetVolumeByRequestIDCalls(stub func(string) (*provider.Volume, error)) {
	fake.getVolumeByRequestIDMutex.Lock()
	defer fake.getVolumeByRequestIDMutex.Unlock()
	fake.GetVolumeByRequestIDStub = stub
}

func (fake *FakeSession) GetVolumeByRequestIDArgsForCall(i int) string {
	fake.getVolumeByRequestIDMutex.RLock()
	defer fake.getVolumeByRequestIDMutex.RUnlock()
	argsForCall := fake.getVolumeByRequestIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) GetVolumeByRequestIDReturns(result1 *provider.Volume, result2 error) {
	fake.getVolumeByRequestIDMutex.Lock()
	defer fake.getVolumeByRequestIDMutex.Unlock()
	fake.GetVolumeByRequestIDStub = nil
	fake.getVolumeByRequestIDReturns = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) GetVolumeByRequestIDReturnsOnCall(i int, result1 *provider.Volume, result2 error) {
	fake.getVolumeByRequestIDMutex.Lock()
	defer fake.getVolumeByRequestIDMutex.Unlock()
	fake.GetVolumeByRequestIDStub = nil
	if fake.getVolumeByRequestIDReturnsOnCall == nil {
		fake.getVolumeByRequestIDReturnsOnCall = make(map[int]struct {
			result1 *provider.Volume
			result2 error
		})
	}
	fake.getVolumeByRequestIDReturnsOnCall[i] = struct {
		result1 *provider.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListAllSnapshots(arg1 string) ([]*provider.Snapshot, error) {
	fake.listAllSnapshotsMutex.Lock()
	ret, specificReturn := fake.listAllSnapshotsReturnsOnCall[len(fake.listAllSnapshotsArgsForCall)]
	fake.listAllSnapshotsArgsForCall = append(fake.listAllSnapshotsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListAllSnapshots", []interface{}{arg1})
	fake.listAllSnapshotsMutex.Unlock()
	if fake.ListAllSnapshotsStub != nil {
		return fake.ListAllSnapshotsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listAllSnapshotsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) ListAllSnapshotsCallCount() int {
	fake.listAllSnapshotsMutex.RLock()
	defer fake.listAllSnapshotsMutex.RUnlock()
	return len(fake.listAllSnapshotsArgsForCall)
}

func (fake *FakeSession) ListAllSnapshotsCalls(stub func(string) ([]*provider.Snapshot, error)) {
	fake.listAllSnapshotsMutex.Lock()
	defer fake.listAllSnapshotsMutex.Unlock()
	fake.ListAllSnapshotsStub = stub
}

func (fake *FakeSession) ListAllSnapshotsArgsForCall(i int) string {
	fake.listAllSnapshotsMutex.RLock()
	defer fake.listAllSnapshotsMutex.RUnlock()
	argsForCall := fake.listAllSnapshotsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) ListAllSnapshotsReturns(result1 []*provider.Snapshot, result2 error) {
	fake.listAllSnapshotsMutex.Lock()
	defer fake.listAllSnapshotsMutex.Unlock()
	fake.ListAllSnapshotsStub = nil
	fake.listAllSnapshotsReturns = struct {
		result1 []*provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListAllSnapshotsReturnsOnCall(i int, result1 []*provider.Snapshot, result2 error) {
	fake.listAllSnapshotsMutex.Lock()
	defer fake.listAllSnapshotsMutex.Unlock()
	fake.ListAllSnapshotsStub = nil
	if fake.listAllSnapshotsReturnsOnCall == nil {
		fake.listAllSnapshotsReturnsOnCall = make(map[int]struct {
			result1 []*provider.Snapshot
			result2 error
		})
	}
	fake.listAllSnapshotsReturnsOnCall[i] = struct {
		result1 []*provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListSnapshots() ([]*provider.Snapshot, error) {
	fake.listSnapshotsMutex.Lock()
	ret, specificReturn := fake.listSnapshotsReturnsOnCall[len(fake.listSnapshotsArgsForCall)]
	fake.listSnapshotsArgsForCall = append(fake.listSnapshotsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListSnapshots", []interface{}{})
	fake.listSnapshotsMutex.Unlock()
	if fake.ListSnapshotsStub != nil {
		return fake.ListSnapshotsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSnapshotsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) ListSnapshotsCallCount() int {
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	return len(fake.listSnapshotsArgsForCall)
}

func (fake *FakeSession) ListSnapshotsCalls(stub func() ([]*provider.Snapshot, error)) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = stub
}

func (fake *FakeSession) ListSnapshotsReturns(result1 []*provider.Snapshot, result2 error) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = nil
	fake.listSnapshotsReturns = struct {
		result1 []*provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListSnapshotsReturnsOnCall(i int, result1 []*provider.Snapshot, result2 error) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = nil
	if fake.listSnapshotsReturnsOnCall == nil {
		fake.listSnapshotsReturnsOnCall = make(map[int]struct {
			result1 []*provider.Snapshot
			result2 error
		})
	}
	fake.listSnapshotsReturnsOnCall[i] = struct {
		result1 []*provider.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListVolumes(arg1 int64, arg2 string, arg3 map[string]string) (*provider.VolumeList, error) {
	fake.listVolumesMutex.Lock()
	ret, specificReturn := fake.listVolumesReturnsOnCall[len(fake.listVolumesArgsForCall)]
	fake.listVolumesArgsForCall = append(fake.listVolumesArgsForCall, struct {
		arg1 int64
		arg2 string
		arg3 map[string]string
	}{arg1, arg2, arg3})
	fake.recordInvocation("ListVolumes", []interface{}{arg1, arg2, arg3})
	fake.listVolumesMutex.Unlock()
	if fake.ListVolumesStub != nil {
		return fake.ListVolumesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listVolumesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) ListVolumesCallCount() int {
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	return len(fake.listVolumesArgsForCall)
}

func (fake *FakeSession) ListVolumesCalls(stub func(int64, string, map[string]string) (*provider.VolumeList, error)) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = stub
}

func (fake *FakeSession) ListVolumesArgsForCall(i int) (int64, string, map[string]string) {
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	argsForCall := fake.listVolumesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSession) ListVolumesReturns(result1 *provider.VolumeList, result2 error) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = nil
	fake.listVolumesReturns = struct {
		result1 *provider.VolumeList
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) ListVolumesReturnsOnCall(i int, result1 *provider.VolumeList, result2 error) {
	fake.listVolumesMutex.Lock()
	defer fake.listVolumesMutex.Unlock()
	fake.ListVolumesStub = nil
	if fake.listVolumesReturnsOnCall == nil {
		fake.listVolumesReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeList
			result2 error
		})
	}
	fake.listVolumesReturnsOnCall[i] = struct {
		result1 *provider.VolumeList
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) OrderSnapshot(arg1 provider.Volume) error {
	fake.orderSnapshotMutex.Lock()
	ret, specificReturn := fake.orderSnapshotReturnsOnCall[len(fake.orderSnapshotArgsForCall)]
	fake.orderSnapshotArgsForCall = append(fake.orderSnapshotArgsForCall, struct {
		arg1 provider.Volume
	}{arg1})
	fake.recordInvocation("OrderSnapshot", []interface{}{arg1})
	fake.orderSnapshotMutex.Unlock()
	if fake.OrderSnapshotStub != nil {
		return fake.OrderSnapshotStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.orderSnapshotReturns
	return fakeReturns.result1
}

func (fake *FakeSession) OrderSnapshotCallCount() int {
	fake.orderSnapshotMutex.RLock()
	defer fake.orderSnapshotMutex.RUnlock()
	return len(fake.orderSnapshotArgsForCall)
}

func (fake *FakeSession) OrderSnapshotCalls(stub func(provider.Volume) error) {
	fake.orderSnapshotMutex.Lock()
	defer fake.orderSnapshotMutex.Unlock()
	fake.OrderSnapshotStub = stub
}

func (fake *FakeSession) OrderSnapshotArgsForCall(i int) provider.Volume {
	fake.orderSnapshotMutex.RLock()
	defer fake.orderSnapshotMutex.RUnlock()
	argsForCall := fake.orderSnapshotArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) OrderSnapshotReturns(result1 error) {
	fake.orderSnapshotMutex.Lock()
	defer fake.orderSnapshotMutex.Unlock()
	fake.OrderSnapshotStub = nil
	fake.orderSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) OrderSnapshotReturnsOnCall(i int, result1 error) {
	fake.orderSnapshotMutex.Lock()
	defer fake.orderSnapshotMutex.Unlock()
	fake.OrderSnapshotStub = nil
	if fake.orderSnapshotReturnsOnCall == nil {
		fake.orderSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.orderSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) ProviderName() provider.VolumeProvider {
	fake.providerNameMutex.Lock()
	ret, specificReturn := fake.providerNameReturnsOnCall[len(fake.providerNameArgsForCall)]
	fake.providerNameArgsForCall = append(fake.providerNameArgsForCall, struct {
	}{})
	fake.recordInvocation("ProviderName", []interface{}{})
	fake.providerNameMutex.Unlock()
	if fake.ProviderNameStub != nil {
		return fake.ProviderNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.providerNameReturns
	return fakeReturns.result1
}

func (fake *FakeSession) ProviderNameCallCount() int {
	fake.providerNameMutex.RLock()
	defer fake.providerNameMutex.RUnlock()
	return len(fake.providerNameArgsForCall)
}

func (fake *FakeSession) ProviderNameCalls(stub func() provider.VolumeProvider) {
	fake.providerNameMutex.Lock()
	defer fake.providerNameMutex.Unlock()
	fake.ProviderNameStub = stub
}

func (fake *FakeSession) ProviderNameReturns(result1 provider.VolumeProvider) {
	fake.providerNameMutex.Lock()
	defer fake.providerNameMutex.Unlock()
	fake.ProviderNameStub = nil
	fake.providerNameReturns = struct {
		result1 provider.VolumeProvider
	}{result1}
}

func (fake *FakeSession) ProviderNameReturnsOnCall(i int, result1 provider.VolumeProvider) {
	fake.providerNameMutex.Lock()
	defer fake.providerNameMutex.Unlock()
	fake.ProviderNameStub = nil
	if fake.providerNameReturnsOnCall == nil {
		fake.providerNameReturnsOnCall = make(map[int]struct {
			result1 provider.VolumeProvider
		})
	}
	fake.providerNameReturnsOnCall[i] = struct {
		result1 provider.VolumeProvider
	}{result1}
}

func (fake *FakeSession) Type() provider.VolumeType {
	fake.typeMutex.Lock()
	ret, specificReturn := fake.typeReturnsOnCall[len(fake.typeArgsForCall)]
	fake.typeArgsForCall = append(fake.typeArgsForCall, struct {
	}{})
	fake.recordInvocation("Type", []interface{}{})
	fake.typeMutex.Unlock()
	if fake.TypeStub != nil {
		return fake.TypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.typeReturns
	return fakeReturns.result1
}

func (fake *FakeSession) TypeCallCount() int {
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	return len(fake.typeArgsForCall)
}

func (fake *FakeSession) TypeCalls(stub func() provider.VolumeType) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = stub
}

func (fake *FakeSession) TypeReturns(result1 provider.VolumeType) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = nil
	fake.typeReturns = struct {
		result1 provider.VolumeType
	}{result1}
}

func (fake *FakeSession) TypeReturnsOnCall(i int, result1 provider.VolumeType) {
	fake.typeMutex.Lock()
	defer fake.typeMutex.Unlock()
	fake.TypeStub = nil
	if fake.typeReturnsOnCall == nil {
		fake.typeReturnsOnCall = make(map[int]struct {
			result1 provider.VolumeType
		})
	}
	fake.typeReturnsOnCall[i] = struct {
		result1 provider.VolumeType
	}{result1}
}

func (fake *FakeSession) UpdateVolume(arg1 provider.Volume) error {
	fake.updateVolumeMutex.Lock()
	ret, specificReturn := fake.updateVolumeReturnsOnCall[len(fake.updateVolumeArgsForCall)]
	fake.updateVolumeArgsForCall = append(fake.updateVolumeArgsForCall, struct {
		arg1 provider.Volume
	}{arg1})
	fake.recordInvocation("UpdateVolume", []interface{}{arg1})
	fake.updateVolumeMutex.Unlock()
	if fake.UpdateVolumeStub != nil {
		return fake.UpdateVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateVolumeReturns
	return fakeReturns.result1
}

func (fake *FakeSession) UpdateVolumeCallCount() int {
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	return len(fake.updateVolumeArgsForCall)
}

func (fake *FakeSession) UpdateVolumeCalls(stub func(provider.Volume) error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = stub
}

func (fake *FakeSession) UpdateVolumeArgsForCall(i int) provider.Volume {
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	argsForCall := fake.updateVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) UpdateVolumeReturns(result1 error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = nil
	fake.updateVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) UpdateVolumeReturnsOnCall(i int, result1 error) {
	fake.updateVolumeMutex.Lock()
	defer fake.updateVolumeMutex.Unlock()
	fake.UpdateVolumeStub = nil
	if fake.updateVolumeReturnsOnCall == nil {
		fake.updateVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) WaitForAttachVolume(arg1 provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) {
	fake.waitForAttachVolumeMutex.Lock()
	ret, specificReturn := fake.waitForAttachVolumeReturnsOnCall[len(fake.waitForAttachVolumeArgsForCall)]
	fake.waitForAttachVolumeArgsForCall = append(fake.waitForAttachVolumeArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	fake.recordInvocation("WaitForAttachVolume", []interface{}{arg1})
	fake.waitForAttachVolumeMutex.Unlock()
	if fake.WaitForAttachVolumeStub != nil {
		return fake.WaitForAttachVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.waitForAttachVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSession) WaitForAttachVolumeCallCount() int {
	fake.waitForAttachVolumeMutex.RLock()
	defer fake.waitForAttachVolumeMutex.RUnlock()
	return len(fake.waitForAttachVolumeArgsForCall)
}

func (fake *FakeSession) WaitForAttachVolumeCalls(stub func(provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error)) {
	fake.waitForAttachVolumeMutex.Lock()
	defer fake.waitForAttachVolumeMutex.Unlock()
	fake.WaitForAttachVolumeStub = stub
}

func (fake *FakeSession) WaitForAttachVolumeArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.waitForAttachVolumeMutex.RLock()
	defer fake.waitForAttachVolumeMutex.RUnlock()
	argsForCall := fake.waitForAttachVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) WaitForAttachVolumeReturns(result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.waitForAttachVolumeMutex.Lock()
	defer fake.waitForAttachVolumeMutex.Unlock()
	fake.WaitForAttachVolumeStub = nil
	fake.waitForAttachVolumeReturns = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) WaitForAttachVolumeReturnsOnCall(i int, result1 *provider.VolumeAttachmentResponse, result2 error) {
	fake.waitForAttachVolumeMutex.Lock()
	defer fake.waitForAttachVolumeMutex.Unlock()
	fake.WaitForAttachVolumeStub = nil
	if fake.waitForAttachVolumeReturnsOnCall == nil {
		fake.waitForAttachVolumeReturnsOnCall = make(map[int]struct {
			result1 *provider.VolumeAttachmentResponse
			result2 error
		})
	}
	fake.waitForAttachVolumeReturnsOnCall[i] = struct {
		result1 *provider.VolumeAttachmentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeSession) WaitForDetachVolume(arg1 provider.VolumeAttachmentRequest) error {
	fake.waitForDetachVolumeMutex.Lock()
	ret, specificReturn := fake.waitForDetachVolumeReturnsOnCall[len(fake.waitForDetachVolumeArgsForCall)]
	fake.waitForDetachVolumeArgsForCall = append(fake.waitForDetachVolumeArgsForCall, struct {
		arg1 provider.VolumeAttachmentRequest
	}{arg1})
	fake.recordInvocation("WaitForDetachVolume", []interface{}{arg1})
	fake.waitForDetachVolumeMutex.Unlock()
	if fake.WaitForDetachVolumeStub != nil {
		return fake.WaitForDetachVolumeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitForDetachVolumeReturns
	return fakeReturns.result1
}

func (fake *FakeSession) WaitForDetachVolumeCallCount() int {
	fake.waitForDetachVolumeMutex.RLock()
	defer fake.waitForDetachVolumeMutex.RUnlock()
	return len(fake.waitForDetachVolumeArgsForCall)
}

func (fake *FakeSession) WaitForDetachVolumeCalls(stub func(provider.VolumeAttachmentRequest) error) {
	fake.waitForDetachVolumeMutex.Lock()
	defer fake.waitForDetachVolumeMutex.Unlock()
	fake.WaitForDetachVolumeStub = stub
}

func (fake *FakeSession) WaitForDetachVolumeArgsForCall(i int) provider.VolumeAttachmentRequest {
	fake.waitForDetachVolumeMutex.RLock()
	defer fake.waitForDetachVolumeMutex.RUnlock()
	argsForCall := fake.waitForDetachVolumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSession) WaitForDetachVolumeReturns(result1 error) {
	fake.waitForDetachVolumeMutex.Lock()
	defer fake.waitForDetachVolumeMutex.Unlock()
	fake.WaitForDetachVolumeStub = nil
	fake.waitForDetachVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) WaitForDetachVolumeReturnsOnCall(i int, result1 error) {
	fake.waitForDetachVolumeMutex.Lock()
	defer fake.waitForDetachVolumeMutex.Unlock()
	fake.WaitForDetachVolumeStub = nil
	if fake.waitForDetachVolumeReturnsOnCall == nil {
		fake.waitForDetachVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForDetachVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSession) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	fake.authorizeVolumeMutex.RLock()
	defer fake.authorizeVolumeMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	fake.createVolumeMutex.RLock()
	defer fake.createVolumeMutex.RUnlock()
	fake.createVolumeFromSnapshotMutex.RLock()
	defer fake.createVolumeFromSnapshotMutex.RUnlock()
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	fake.deleteVolumeMutex.RLock()
	defer fake.deleteVolumeMutex.RUnlock()
	fake.detachVolumeMutex.RLock()
	defer fake.detachVolumeMutex.RUnlock()
	fake.getProviderDisplayNameMutex.RLock()
	defer fake.getProviderDisplayNameMutex.RUnlock()
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	fake.getSnapshotWithVolumeIDMutex.RLock()
	defer fake.getSnapshotWithVolumeIDMutex.RUnlock()
	fake.getVolumeMutex.RLock()
	defer fake.getVolumeMutex.RUnlock()
	fake.getVolumeAttachmentMutex.RLock()
	defer fake.getVolumeAttachmentMutex.RUnlock()
	fake.getVolumeByNameMutex.RLock()
	defer fake.getVolumeByNameMutex.RUnlock()
	fake.getVolumeByRequestIDMutex.RLock()
	defer fake.getVolumeByRequestIDMutex.RUnlock()
	fake.listAllSnapshotsMutex.RLock()
	defer fake.listAllSnapshotsMutex.RUnlock()
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	fake.listVolumesMutex.RLock()
	defer fake.listVolumesMutex.RUnlock()
	fake.orderSnapshotMutex.RLock()
	defer fake.orderSnapshotMutex.RUnlock()
	fake.providerNameMutex.RLock()
	defer fake.providerNameMutex.RUnlock()
	fake.typeMutex.RLock()
	defer fake.typeMutex.RUnlock()
	fake.updateVolumeMutex.RLock()
	defer fake.updateVolumeMutex.RUnlock()
	fake.waitForAttachVolumeMutex.RLock()
	defer fake.waitForAttachVolumeMutex.RUnlock()
	fake.waitForDetachVolumeMutex.RLock()
	defer fake.waitForDetachVolumeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSession) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ provider.Session = new(FakeSession)
