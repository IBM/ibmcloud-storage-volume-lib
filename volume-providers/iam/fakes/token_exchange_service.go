// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/IBM/ibmcloud-storage-volume-lib/volume-providers/iam"
	"go.uber.org/zap"
)

type TokenExchangeService struct {
	ExchangeAccessTokenForIMSTokenStub        func(iam.AccessToken, *zap.Logger) (*iam.IMSToken, error)
	exchangeAccessTokenForIMSTokenMutex       sync.RWMutex
	exchangeAccessTokenForIMSTokenArgsForCall []struct {
		arg1 iam.AccessToken
		arg2 *zap.Logger
	}
	exchangeAccessTokenForIMSTokenReturns struct {
		result1 *iam.IMSToken
		result2 error
	}
	exchangeAccessTokenForIMSTokenReturnsOnCall map[int]struct {
		result1 *iam.IMSToken
		result2 error
	}
	ExchangeIAMAPIKeyForAccessTokenStub        func(string, *zap.Logger) (*iam.AccessToken, error)
	exchangeIAMAPIKeyForAccessTokenMutex       sync.RWMutex
	exchangeIAMAPIKeyForAccessTokenArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	exchangeIAMAPIKeyForAccessTokenReturns struct {
		result1 *iam.AccessToken
		result2 error
	}
	exchangeIAMAPIKeyForAccessTokenReturnsOnCall map[int]struct {
		result1 *iam.AccessToken
		result2 error
	}
	ExchangeIAMAPIKeyForIMSTokenStub        func(string, *zap.Logger) (*iam.IMSToken, error)
	exchangeIAMAPIKeyForIMSTokenMutex       sync.RWMutex
	exchangeIAMAPIKeyForIMSTokenArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	exchangeIAMAPIKeyForIMSTokenReturns struct {
		result1 *iam.IMSToken
		result2 error
	}
	exchangeIAMAPIKeyForIMSTokenReturnsOnCall map[int]struct {
		result1 *iam.IMSToken
		result2 error
	}
	ExchangeRefreshTokenForAccessTokenStub        func(string, *zap.Logger) (*iam.AccessToken, error)
	exchangeRefreshTokenForAccessTokenMutex       sync.RWMutex
	exchangeRefreshTokenForAccessTokenArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	exchangeRefreshTokenForAccessTokenReturns struct {
		result1 *iam.AccessToken
		result2 error
	}
	exchangeRefreshTokenForAccessTokenReturnsOnCall map[int]struct {
		result1 *iam.AccessToken
		result2 error
	}
	GetIAMAccountIDFromAccessTokenStub        func(iam.AccessToken, *zap.Logger) (string, error)
	getIAMAccountIDFromAccessTokenMutex       sync.RWMutex
	getIAMAccountIDFromAccessTokenArgsForCall []struct {
		arg1 iam.AccessToken
		arg2 *zap.Logger
	}
	getIAMAccountIDFromAccessTokenReturns struct {
		result1 string
		result2 error
	}
	getIAMAccountIDFromAccessTokenReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSToken(arg1 iam.AccessToken, arg2 *zap.Logger) (*iam.IMSToken, error) {
	fake.exchangeAccessTokenForIMSTokenMutex.Lock()
	ret, specificReturn := fake.exchangeAccessTokenForIMSTokenReturnsOnCall[len(fake.exchangeAccessTokenForIMSTokenArgsForCall)]
	fake.exchangeAccessTokenForIMSTokenArgsForCall = append(fake.exchangeAccessTokenForIMSTokenArgsForCall, struct {
		arg1 iam.AccessToken
		arg2 *zap.Logger
	}{arg1, arg2})
	fake.recordInvocation("ExchangeAccessTokenForIMSToken", []interface{}{arg1, arg2})
	fake.exchangeAccessTokenForIMSTokenMutex.Unlock()
	if fake.ExchangeAccessTokenForIMSTokenStub != nil {
		return fake.ExchangeAccessTokenForIMSTokenStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.exchangeAccessTokenForIMSTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenCallCount() int {
	fake.exchangeAccessTokenForIMSTokenMutex.RLock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.RUnlock()
	return len(fake.exchangeAccessTokenForIMSTokenArgsForCall)
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenCalls(stub func(iam.AccessToken, *zap.Logger) (*iam.IMSToken, error)) {
	fake.exchangeAccessTokenForIMSTokenMutex.Lock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.Unlock()
	fake.ExchangeAccessTokenForIMSTokenStub = stub
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenArgsForCall(i int) (iam.AccessToken, *zap.Logger) {
	fake.exchangeAccessTokenForIMSTokenMutex.RLock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.RUnlock()
	argsForCall := fake.exchangeAccessTokenForIMSTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenReturns(result1 *iam.IMSToken, result2 error) {
	fake.exchangeAccessTokenForIMSTokenMutex.Lock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.Unlock()
	fake.ExchangeAccessTokenForIMSTokenStub = nil
	fake.exchangeAccessTokenForIMSTokenReturns = struct {
		result1 *iam.IMSToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenReturnsOnCall(i int, result1 *iam.IMSToken, result2 error) {
	fake.exchangeAccessTokenForIMSTokenMutex.Lock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.Unlock()
	fake.ExchangeAccessTokenForIMSTokenStub = nil
	if fake.exchangeAccessTokenForIMSTokenReturnsOnCall == nil {
		fake.exchangeAccessTokenForIMSTokenReturnsOnCall = make(map[int]struct {
			result1 *iam.IMSToken
			result2 error
		})
	}
	fake.exchangeAccessTokenForIMSTokenReturnsOnCall[i] = struct {
		result1 *iam.IMSToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessToken(arg1 string, arg2 *zap.Logger) (*iam.AccessToken, error) {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.Lock()
	ret, specificReturn := fake.exchangeIAMAPIKeyForAccessTokenReturnsOnCall[len(fake.exchangeIAMAPIKeyForAccessTokenArgsForCall)]
	fake.exchangeIAMAPIKeyForAccessTokenArgsForCall = append(fake.exchangeIAMAPIKeyForAccessTokenArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	fake.recordInvocation("ExchangeIAMAPIKeyForAccessToken", []interface{}{arg1, arg2})
	fake.exchangeIAMAPIKeyForAccessTokenMutex.Unlock()
	if fake.ExchangeIAMAPIKeyForAccessTokenStub != nil {
		return fake.ExchangeIAMAPIKeyForAccessTokenStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.exchangeIAMAPIKeyForAccessTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenCallCount() int {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.RUnlock()
	return len(fake.exchangeIAMAPIKeyForAccessTokenArgsForCall)
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenCalls(stub func(string, *zap.Logger) (*iam.AccessToken, error)) {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.Lock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.Unlock()
	fake.ExchangeIAMAPIKeyForAccessTokenStub = stub
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenArgsForCall(i int) (string, *zap.Logger) {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.RUnlock()
	argsForCall := fake.exchangeIAMAPIKeyForAccessTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenReturns(result1 *iam.AccessToken, result2 error) {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.Lock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.Unlock()
	fake.ExchangeIAMAPIKeyForAccessTokenStub = nil
	fake.exchangeIAMAPIKeyForAccessTokenReturns = struct {
		result1 *iam.AccessToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenReturnsOnCall(i int, result1 *iam.AccessToken, result2 error) {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.Lock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.Unlock()
	fake.ExchangeIAMAPIKeyForAccessTokenStub = nil
	if fake.exchangeIAMAPIKeyForAccessTokenReturnsOnCall == nil {
		fake.exchangeIAMAPIKeyForAccessTokenReturnsOnCall = make(map[int]struct {
			result1 *iam.AccessToken
			result2 error
		})
	}
	fake.exchangeIAMAPIKeyForAccessTokenReturnsOnCall[i] = struct {
		result1 *iam.AccessToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSToken(arg1 string, arg2 *zap.Logger) (*iam.IMSToken, error) {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.Lock()
	ret, specificReturn := fake.exchangeIAMAPIKeyForIMSTokenReturnsOnCall[len(fake.exchangeIAMAPIKeyForIMSTokenArgsForCall)]
	fake.exchangeIAMAPIKeyForIMSTokenArgsForCall = append(fake.exchangeIAMAPIKeyForIMSTokenArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	fake.recordInvocation("ExchangeIAMAPIKeyForIMSToken", []interface{}{arg1, arg2})
	fake.exchangeIAMAPIKeyForIMSTokenMutex.Unlock()
	if fake.ExchangeIAMAPIKeyForIMSTokenStub != nil {
		return fake.ExchangeIAMAPIKeyForIMSTokenStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.exchangeIAMAPIKeyForIMSTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenCallCount() int {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.RUnlock()
	return len(fake.exchangeIAMAPIKeyForIMSTokenArgsForCall)
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenCalls(stub func(string, *zap.Logger) (*iam.IMSToken, error)) {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.Lock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.Unlock()
	fake.ExchangeIAMAPIKeyForIMSTokenStub = stub
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenArgsForCall(i int) (string, *zap.Logger) {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.RUnlock()
	argsForCall := fake.exchangeIAMAPIKeyForIMSTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenReturns(result1 *iam.IMSToken, result2 error) {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.Lock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.Unlock()
	fake.ExchangeIAMAPIKeyForIMSTokenStub = nil
	fake.exchangeIAMAPIKeyForIMSTokenReturns = struct {
		result1 *iam.IMSToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenReturnsOnCall(i int, result1 *iam.IMSToken, result2 error) {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.Lock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.Unlock()
	fake.ExchangeIAMAPIKeyForIMSTokenStub = nil
	if fake.exchangeIAMAPIKeyForIMSTokenReturnsOnCall == nil {
		fake.exchangeIAMAPIKeyForIMSTokenReturnsOnCall = make(map[int]struct {
			result1 *iam.IMSToken
			result2 error
		})
	}
	fake.exchangeIAMAPIKeyForIMSTokenReturnsOnCall[i] = struct {
		result1 *iam.IMSToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessToken(arg1 string, arg2 *zap.Logger) (*iam.AccessToken, error) {
	fake.exchangeRefreshTokenForAccessTokenMutex.Lock()
	ret, specificReturn := fake.exchangeRefreshTokenForAccessTokenReturnsOnCall[len(fake.exchangeRefreshTokenForAccessTokenArgsForCall)]
	fake.exchangeRefreshTokenForAccessTokenArgsForCall = append(fake.exchangeRefreshTokenForAccessTokenArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	fake.recordInvocation("ExchangeRefreshTokenForAccessToken", []interface{}{arg1, arg2})
	fake.exchangeRefreshTokenForAccessTokenMutex.Unlock()
	if fake.ExchangeRefreshTokenForAccessTokenStub != nil {
		return fake.ExchangeRefreshTokenForAccessTokenStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.exchangeRefreshTokenForAccessTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenCallCount() int {
	fake.exchangeRefreshTokenForAccessTokenMutex.RLock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.RUnlock()
	return len(fake.exchangeRefreshTokenForAccessTokenArgsForCall)
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenCalls(stub func(string, *zap.Logger) (*iam.AccessToken, error)) {
	fake.exchangeRefreshTokenForAccessTokenMutex.Lock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.Unlock()
	fake.ExchangeRefreshTokenForAccessTokenStub = stub
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenArgsForCall(i int) (string, *zap.Logger) {
	fake.exchangeRefreshTokenForAccessTokenMutex.RLock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.RUnlock()
	argsForCall := fake.exchangeRefreshTokenForAccessTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenReturns(result1 *iam.AccessToken, result2 error) {
	fake.exchangeRefreshTokenForAccessTokenMutex.Lock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.Unlock()
	fake.ExchangeRefreshTokenForAccessTokenStub = nil
	fake.exchangeRefreshTokenForAccessTokenReturns = struct {
		result1 *iam.AccessToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenReturnsOnCall(i int, result1 *iam.AccessToken, result2 error) {
	fake.exchangeRefreshTokenForAccessTokenMutex.Lock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.Unlock()
	fake.ExchangeRefreshTokenForAccessTokenStub = nil
	if fake.exchangeRefreshTokenForAccessTokenReturnsOnCall == nil {
		fake.exchangeRefreshTokenForAccessTokenReturnsOnCall = make(map[int]struct {
			result1 *iam.AccessToken
			result2 error
		})
	}
	fake.exchangeRefreshTokenForAccessTokenReturnsOnCall[i] = struct {
		result1 *iam.AccessToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) GetIAMAccountIDFromAccessToken(arg1 iam.AccessToken, arg2 *zap.Logger) (string, error) {
	fake.getIAMAccountIDFromAccessTokenMutex.Lock()
	ret, specificReturn := fake.getIAMAccountIDFromAccessTokenReturnsOnCall[len(fake.getIAMAccountIDFromAccessTokenArgsForCall)]
	fake.getIAMAccountIDFromAccessTokenArgsForCall = append(fake.getIAMAccountIDFromAccessTokenArgsForCall, struct {
		arg1 iam.AccessToken
		arg2 *zap.Logger
	}{arg1, arg2})
	fake.recordInvocation("GetIAMAccountIDFromAccessToken", []interface{}{arg1, arg2})
	fake.getIAMAccountIDFromAccessTokenMutex.Unlock()
	if fake.GetIAMAccountIDFromAccessTokenStub != nil {
		return fake.GetIAMAccountIDFromAccessTokenStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getIAMAccountIDFromAccessTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TokenExchangeService) GetIAMAccountIDFromAccessTokenCallCount() int {
	fake.getIAMAccountIDFromAccessTokenMutex.RLock()
	defer fake.getIAMAccountIDFromAccessTokenMutex.RUnlock()
	return len(fake.getIAMAccountIDFromAccessTokenArgsForCall)
}

func (fake *TokenExchangeService) GetIAMAccountIDFromAccessTokenCalls(stub func(iam.AccessToken, *zap.Logger) (string, error)) {
	fake.getIAMAccountIDFromAccessTokenMutex.Lock()
	defer fake.getIAMAccountIDFromAccessTokenMutex.Unlock()
	fake.GetIAMAccountIDFromAccessTokenStub = stub
}

func (fake *TokenExchangeService) GetIAMAccountIDFromAccessTokenArgsForCall(i int) (iam.AccessToken, *zap.Logger) {
	fake.getIAMAccountIDFromAccessTokenMutex.RLock()
	defer fake.getIAMAccountIDFromAccessTokenMutex.RUnlock()
	argsForCall := fake.getIAMAccountIDFromAccessTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TokenExchangeService) GetIAMAccountIDFromAccessTokenReturns(result1 string, result2 error) {
	fake.getIAMAccountIDFromAccessTokenMutex.Lock()
	defer fake.getIAMAccountIDFromAccessTokenMutex.Unlock()
	fake.GetIAMAccountIDFromAccessTokenStub = nil
	fake.getIAMAccountIDFromAccessTokenReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) GetIAMAccountIDFromAccessTokenReturnsOnCall(i int, result1 string, result2 error) {
	fake.getIAMAccountIDFromAccessTokenMutex.Lock()
	defer fake.getIAMAccountIDFromAccessTokenMutex.Unlock()
	fake.GetIAMAccountIDFromAccessTokenStub = nil
	if fake.getIAMAccountIDFromAccessTokenReturnsOnCall == nil {
		fake.getIAMAccountIDFromAccessTokenReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getIAMAccountIDFromAccessTokenReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.exchangeAccessTokenForIMSTokenMutex.RLock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.RUnlock()
	fake.exchangeIAMAPIKeyForAccessTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.RUnlock()
	fake.exchangeIAMAPIKeyForIMSTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.RUnlock()
	fake.exchangeRefreshTokenForAccessTokenMutex.RLock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.RUnlock()
	fake.getIAMAccountIDFromAccessTokenMutex.RLock()
	defer fake.getIAMAccountIDFromAccessTokenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TokenExchangeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ iam.TokenExchangeService = new(TokenExchangeService)
