// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/IBM/ibmcloud-storage-volume-lib/volume-providers/vpc/vpcclient/models"
	"github.com/IBM/ibmcloud-storage-volume-lib/volume-providers/vpc/vpcclient/vpcvolume"
	"go.uber.org/zap"
)

type SnapshotService struct {
	CheckSnapshotTagStub        func(string, string, string, *zap.Logger) error
	checkSnapshotTagMutex       sync.RWMutex
	checkSnapshotTagArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *zap.Logger
	}
	checkSnapshotTagReturns struct {
		result1 error
	}
	checkSnapshotTagReturnsOnCall map[int]struct {
		result1 error
	}
	CreateSnapshotStub        func(string, *models.Snapshot, *zap.Logger) (*models.Snapshot, error)
	createSnapshotMutex       sync.RWMutex
	createSnapshotArgsForCall []struct {
		arg1 string
		arg2 *models.Snapshot
		arg3 *zap.Logger
	}
	createSnapshotReturns struct {
		result1 *models.Snapshot
		result2 error
	}
	createSnapshotReturnsOnCall map[int]struct {
		result1 *models.Snapshot
		result2 error
	}
	DeleteSnapshotStub        func(string, string, *zap.Logger) error
	deleteSnapshotMutex       sync.RWMutex
	deleteSnapshotArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	deleteSnapshotReturns struct {
		result1 error
	}
	deleteSnapshotReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSnapshotTagStub        func(string, string, string, *zap.Logger) error
	deleteSnapshotTagMutex       sync.RWMutex
	deleteSnapshotTagArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *zap.Logger
	}
	deleteSnapshotTagReturns struct {
		result1 error
	}
	deleteSnapshotTagReturnsOnCall map[int]struct {
		result1 error
	}
	GetSnapshotStub        func(string, string, *zap.Logger) (*models.Snapshot, error)
	getSnapshotMutex       sync.RWMutex
	getSnapshotArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	getSnapshotReturns struct {
		result1 *models.Snapshot
		result2 error
	}
	getSnapshotReturnsOnCall map[int]struct {
		result1 *models.Snapshot
		result2 error
	}
	ListSnapshotTagsStub        func(string, string, *zap.Logger) (*[]string, error)
	listSnapshotTagsMutex       sync.RWMutex
	listSnapshotTagsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	listSnapshotTagsReturns struct {
		result1 *[]string
		result2 error
	}
	listSnapshotTagsReturnsOnCall map[int]struct {
		result1 *[]string
		result2 error
	}
	ListSnapshotsStub        func(string, *zap.Logger) (*models.SnapshotList, error)
	listSnapshotsMutex       sync.RWMutex
	listSnapshotsArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	listSnapshotsReturns struct {
		result1 *models.SnapshotList
		result2 error
	}
	listSnapshotsReturnsOnCall map[int]struct {
		result1 *models.SnapshotList
		result2 error
	}
	SetSnapshotTagStub        func(string, string, string, *zap.Logger) error
	setSnapshotTagMutex       sync.RWMutex
	setSnapshotTagArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *zap.Logger
	}
	setSnapshotTagReturns struct {
		result1 error
	}
	setSnapshotTagReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *SnapshotService) CheckSnapshotTag(arg1 string, arg2 string, arg3 string, arg4 *zap.Logger) error {
	fake.checkSnapshotTagMutex.Lock()
	ret, specificReturn := fake.checkSnapshotTagReturnsOnCall[len(fake.checkSnapshotTagArgsForCall)]
	fake.checkSnapshotTagArgsForCall = append(fake.checkSnapshotTagArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *zap.Logger
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("CheckSnapshotTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.checkSnapshotTagMutex.Unlock()
	if fake.CheckSnapshotTagStub != nil {
		return fake.CheckSnapshotTagStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.checkSnapshotTagReturns
	return fakeReturns.result1
}

func (fake *SnapshotService) CheckSnapshotTagCallCount() int {
	fake.checkSnapshotTagMutex.RLock()
	defer fake.checkSnapshotTagMutex.RUnlock()
	return len(fake.checkSnapshotTagArgsForCall)
}

func (fake *SnapshotService) CheckSnapshotTagCalls(stub func(string, string, string, *zap.Logger) error) {
	fake.checkSnapshotTagMutex.Lock()
	defer fake.checkSnapshotTagMutex.Unlock()
	fake.CheckSnapshotTagStub = stub
}

func (fake *SnapshotService) CheckSnapshotTagArgsForCall(i int) (string, string, string, *zap.Logger) {
	fake.checkSnapshotTagMutex.RLock()
	defer fake.checkSnapshotTagMutex.RUnlock()
	argsForCall := fake.checkSnapshotTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *SnapshotService) CheckSnapshotTagReturns(result1 error) {
	fake.checkSnapshotTagMutex.Lock()
	defer fake.checkSnapshotTagMutex.Unlock()
	fake.CheckSnapshotTagStub = nil
	fake.checkSnapshotTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) CheckSnapshotTagReturnsOnCall(i int, result1 error) {
	fake.checkSnapshotTagMutex.Lock()
	defer fake.checkSnapshotTagMutex.Unlock()
	fake.CheckSnapshotTagStub = nil
	if fake.checkSnapshotTagReturnsOnCall == nil {
		fake.checkSnapshotTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkSnapshotTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) CreateSnapshot(arg1 string, arg2 *models.Snapshot, arg3 *zap.Logger) (*models.Snapshot, error) {
	fake.createSnapshotMutex.Lock()
	ret, specificReturn := fake.createSnapshotReturnsOnCall[len(fake.createSnapshotArgsForCall)]
	fake.createSnapshotArgsForCall = append(fake.createSnapshotArgsForCall, struct {
		arg1 string
		arg2 *models.Snapshot
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateSnapshot", []interface{}{arg1, arg2, arg3})
	fake.createSnapshotMutex.Unlock()
	if fake.CreateSnapshotStub != nil {
		return fake.CreateSnapshotStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createSnapshotReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SnapshotService) CreateSnapshotCallCount() int {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	return len(fake.createSnapshotArgsForCall)
}

func (fake *SnapshotService) CreateSnapshotCalls(stub func(string, *models.Snapshot, *zap.Logger) (*models.Snapshot, error)) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = stub
}

func (fake *SnapshotService) CreateSnapshotArgsForCall(i int) (string, *models.Snapshot, *zap.Logger) {
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	argsForCall := fake.createSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *SnapshotService) CreateSnapshotReturns(result1 *models.Snapshot, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	fake.createSnapshotReturns = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) CreateSnapshotReturnsOnCall(i int, result1 *models.Snapshot, result2 error) {
	fake.createSnapshotMutex.Lock()
	defer fake.createSnapshotMutex.Unlock()
	fake.CreateSnapshotStub = nil
	if fake.createSnapshotReturnsOnCall == nil {
		fake.createSnapshotReturnsOnCall = make(map[int]struct {
			result1 *models.Snapshot
			result2 error
		})
	}
	fake.createSnapshotReturnsOnCall[i] = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) DeleteSnapshot(arg1 string, arg2 string, arg3 *zap.Logger) error {
	fake.deleteSnapshotMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotReturnsOnCall[len(fake.deleteSnapshotArgsForCall)]
	fake.deleteSnapshotArgsForCall = append(fake.deleteSnapshotArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteSnapshot", []interface{}{arg1, arg2, arg3})
	fake.deleteSnapshotMutex.Unlock()
	if fake.DeleteSnapshotStub != nil {
		return fake.DeleteSnapshotStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteSnapshotReturns
	return fakeReturns.result1
}

func (fake *SnapshotService) DeleteSnapshotCallCount() int {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	return len(fake.deleteSnapshotArgsForCall)
}

func (fake *SnapshotService) DeleteSnapshotCalls(stub func(string, string, *zap.Logger) error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = stub
}

func (fake *SnapshotService) DeleteSnapshotArgsForCall(i int) (string, string, *zap.Logger) {
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	argsForCall := fake.deleteSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *SnapshotService) DeleteSnapshotReturns(result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	fake.deleteSnapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) DeleteSnapshotReturnsOnCall(i int, result1 error) {
	fake.deleteSnapshotMutex.Lock()
	defer fake.deleteSnapshotMutex.Unlock()
	fake.DeleteSnapshotStub = nil
	if fake.deleteSnapshotReturnsOnCall == nil {
		fake.deleteSnapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) DeleteSnapshotTag(arg1 string, arg2 string, arg3 string, arg4 *zap.Logger) error {
	fake.deleteSnapshotTagMutex.Lock()
	ret, specificReturn := fake.deleteSnapshotTagReturnsOnCall[len(fake.deleteSnapshotTagArgsForCall)]
	fake.deleteSnapshotTagArgsForCall = append(fake.deleteSnapshotTagArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *zap.Logger
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("DeleteSnapshotTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteSnapshotTagMutex.Unlock()
	if fake.DeleteSnapshotTagStub != nil {
		return fake.DeleteSnapshotTagStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteSnapshotTagReturns
	return fakeReturns.result1
}

func (fake *SnapshotService) DeleteSnapshotTagCallCount() int {
	fake.deleteSnapshotTagMutex.RLock()
	defer fake.deleteSnapshotTagMutex.RUnlock()
	return len(fake.deleteSnapshotTagArgsForCall)
}

func (fake *SnapshotService) DeleteSnapshotTagCalls(stub func(string, string, string, *zap.Logger) error) {
	fake.deleteSnapshotTagMutex.Lock()
	defer fake.deleteSnapshotTagMutex.Unlock()
	fake.DeleteSnapshotTagStub = stub
}

func (fake *SnapshotService) DeleteSnapshotTagArgsForCall(i int) (string, string, string, *zap.Logger) {
	fake.deleteSnapshotTagMutex.RLock()
	defer fake.deleteSnapshotTagMutex.RUnlock()
	argsForCall := fake.deleteSnapshotTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *SnapshotService) DeleteSnapshotTagReturns(result1 error) {
	fake.deleteSnapshotTagMutex.Lock()
	defer fake.deleteSnapshotTagMutex.Unlock()
	fake.DeleteSnapshotTagStub = nil
	fake.deleteSnapshotTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) DeleteSnapshotTagReturnsOnCall(i int, result1 error) {
	fake.deleteSnapshotTagMutex.Lock()
	defer fake.deleteSnapshotTagMutex.Unlock()
	fake.DeleteSnapshotTagStub = nil
	if fake.deleteSnapshotTagReturnsOnCall == nil {
		fake.deleteSnapshotTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSnapshotTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) GetSnapshot(arg1 string, arg2 string, arg3 *zap.Logger) (*models.Snapshot, error) {
	fake.getSnapshotMutex.Lock()
	ret, specificReturn := fake.getSnapshotReturnsOnCall[len(fake.getSnapshotArgsForCall)]
	fake.getSnapshotArgsForCall = append(fake.getSnapshotArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetSnapshot", []interface{}{arg1, arg2, arg3})
	fake.getSnapshotMutex.Unlock()
	if fake.GetSnapshotStub != nil {
		return fake.GetSnapshotStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSnapshotReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SnapshotService) GetSnapshotCallCount() int {
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	return len(fake.getSnapshotArgsForCall)
}

func (fake *SnapshotService) GetSnapshotCalls(stub func(string, string, *zap.Logger) (*models.Snapshot, error)) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = stub
}

func (fake *SnapshotService) GetSnapshotArgsForCall(i int) (string, string, *zap.Logger) {
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	argsForCall := fake.getSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *SnapshotService) GetSnapshotReturns(result1 *models.Snapshot, result2 error) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = nil
	fake.getSnapshotReturns = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) GetSnapshotReturnsOnCall(i int, result1 *models.Snapshot, result2 error) {
	fake.getSnapshotMutex.Lock()
	defer fake.getSnapshotMutex.Unlock()
	fake.GetSnapshotStub = nil
	if fake.getSnapshotReturnsOnCall == nil {
		fake.getSnapshotReturnsOnCall = make(map[int]struct {
			result1 *models.Snapshot
			result2 error
		})
	}
	fake.getSnapshotReturnsOnCall[i] = struct {
		result1 *models.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) ListSnapshotTags(arg1 string, arg2 string, arg3 *zap.Logger) (*[]string, error) {
	fake.listSnapshotTagsMutex.Lock()
	ret, specificReturn := fake.listSnapshotTagsReturnsOnCall[len(fake.listSnapshotTagsArgsForCall)]
	fake.listSnapshotTagsArgsForCall = append(fake.listSnapshotTagsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	fake.recordInvocation("ListSnapshotTags", []interface{}{arg1, arg2, arg3})
	fake.listSnapshotTagsMutex.Unlock()
	if fake.ListSnapshotTagsStub != nil {
		return fake.ListSnapshotTagsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSnapshotTagsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SnapshotService) ListSnapshotTagsCallCount() int {
	fake.listSnapshotTagsMutex.RLock()
	defer fake.listSnapshotTagsMutex.RUnlock()
	return len(fake.listSnapshotTagsArgsForCall)
}

func (fake *SnapshotService) ListSnapshotTagsCalls(stub func(string, string, *zap.Logger) (*[]string, error)) {
	fake.listSnapshotTagsMutex.Lock()
	defer fake.listSnapshotTagsMutex.Unlock()
	fake.ListSnapshotTagsStub = stub
}

func (fake *SnapshotService) ListSnapshotTagsArgsForCall(i int) (string, string, *zap.Logger) {
	fake.listSnapshotTagsMutex.RLock()
	defer fake.listSnapshotTagsMutex.RUnlock()
	argsForCall := fake.listSnapshotTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *SnapshotService) ListSnapshotTagsReturns(result1 *[]string, result2 error) {
	fake.listSnapshotTagsMutex.Lock()
	defer fake.listSnapshotTagsMutex.Unlock()
	fake.ListSnapshotTagsStub = nil
	fake.listSnapshotTagsReturns = struct {
		result1 *[]string
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) ListSnapshotTagsReturnsOnCall(i int, result1 *[]string, result2 error) {
	fake.listSnapshotTagsMutex.Lock()
	defer fake.listSnapshotTagsMutex.Unlock()
	fake.ListSnapshotTagsStub = nil
	if fake.listSnapshotTagsReturnsOnCall == nil {
		fake.listSnapshotTagsReturnsOnCall = make(map[int]struct {
			result1 *[]string
			result2 error
		})
	}
	fake.listSnapshotTagsReturnsOnCall[i] = struct {
		result1 *[]string
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) ListSnapshots(arg1 string, arg2 *zap.Logger) (*models.SnapshotList, error) {
	fake.listSnapshotsMutex.Lock()
	ret, specificReturn := fake.listSnapshotsReturnsOnCall[len(fake.listSnapshotsArgsForCall)]
	fake.listSnapshotsArgsForCall = append(fake.listSnapshotsArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	fake.recordInvocation("ListSnapshots", []interface{}{arg1, arg2})
	fake.listSnapshotsMutex.Unlock()
	if fake.ListSnapshotsStub != nil {
		return fake.ListSnapshotsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSnapshotsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *SnapshotService) ListSnapshotsCallCount() int {
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	return len(fake.listSnapshotsArgsForCall)
}

func (fake *SnapshotService) ListSnapshotsCalls(stub func(string, *zap.Logger) (*models.SnapshotList, error)) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = stub
}

func (fake *SnapshotService) ListSnapshotsArgsForCall(i int) (string, *zap.Logger) {
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	argsForCall := fake.listSnapshotsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *SnapshotService) ListSnapshotsReturns(result1 *models.SnapshotList, result2 error) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = nil
	fake.listSnapshotsReturns = struct {
		result1 *models.SnapshotList
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) ListSnapshotsReturnsOnCall(i int, result1 *models.SnapshotList, result2 error) {
	fake.listSnapshotsMutex.Lock()
	defer fake.listSnapshotsMutex.Unlock()
	fake.ListSnapshotsStub = nil
	if fake.listSnapshotsReturnsOnCall == nil {
		fake.listSnapshotsReturnsOnCall = make(map[int]struct {
			result1 *models.SnapshotList
			result2 error
		})
	}
	fake.listSnapshotsReturnsOnCall[i] = struct {
		result1 *models.SnapshotList
		result2 error
	}{result1, result2}
}

func (fake *SnapshotService) SetSnapshotTag(arg1 string, arg2 string, arg3 string, arg4 *zap.Logger) error {
	fake.setSnapshotTagMutex.Lock()
	ret, specificReturn := fake.setSnapshotTagReturnsOnCall[len(fake.setSnapshotTagArgsForCall)]
	fake.setSnapshotTagArgsForCall = append(fake.setSnapshotTagArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *zap.Logger
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("SetSnapshotTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.setSnapshotTagMutex.Unlock()
	if fake.SetSnapshotTagStub != nil {
		return fake.SetSnapshotTagStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setSnapshotTagReturns
	return fakeReturns.result1
}

func (fake *SnapshotService) SetSnapshotTagCallCount() int {
	fake.setSnapshotTagMutex.RLock()
	defer fake.setSnapshotTagMutex.RUnlock()
	return len(fake.setSnapshotTagArgsForCall)
}

func (fake *SnapshotService) SetSnapshotTagCalls(stub func(string, string, string, *zap.Logger) error) {
	fake.setSnapshotTagMutex.Lock()
	defer fake.setSnapshotTagMutex.Unlock()
	fake.SetSnapshotTagStub = stub
}

func (fake *SnapshotService) SetSnapshotTagArgsForCall(i int) (string, string, string, *zap.Logger) {
	fake.setSnapshotTagMutex.RLock()
	defer fake.setSnapshotTagMutex.RUnlock()
	argsForCall := fake.setSnapshotTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *SnapshotService) SetSnapshotTagReturns(result1 error) {
	fake.setSnapshotTagMutex.Lock()
	defer fake.setSnapshotTagMutex.Unlock()
	fake.SetSnapshotTagStub = nil
	fake.setSnapshotTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) SetSnapshotTagReturnsOnCall(i int, result1 error) {
	fake.setSnapshotTagMutex.Lock()
	defer fake.setSnapshotTagMutex.Unlock()
	fake.SetSnapshotTagStub = nil
	if fake.setSnapshotTagReturnsOnCall == nil {
		fake.setSnapshotTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setSnapshotTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *SnapshotService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkSnapshotTagMutex.RLock()
	defer fake.checkSnapshotTagMutex.RUnlock()
	fake.createSnapshotMutex.RLock()
	defer fake.createSnapshotMutex.RUnlock()
	fake.deleteSnapshotMutex.RLock()
	defer fake.deleteSnapshotMutex.RUnlock()
	fake.deleteSnapshotTagMutex.RLock()
	defer fake.deleteSnapshotTagMutex.RUnlock()
	fake.getSnapshotMutex.RLock()
	defer fake.getSnapshotMutex.RUnlock()
	fake.listSnapshotTagsMutex.RLock()
	defer fake.listSnapshotTagsMutex.RUnlock()
	fake.listSnapshotsMutex.RLock()
	defer fake.listSnapshotsMutex.RUnlock()
	fake.setSnapshotTagMutex.RLock()
	defer fake.setSnapshotTagMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *SnapshotService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ vpcvolume.SnapshotManager = new(SnapshotService)
