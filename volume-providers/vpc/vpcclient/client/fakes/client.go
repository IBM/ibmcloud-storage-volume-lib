// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"

	"github.com/IBM/ibmcloud-storage-volume-lib/volume-providers/vpc/vpcclient/client"
)

type SessionClient struct {
	NewRequestStub        func(*client.Operation) *client.Request
	newRequestMutex       sync.RWMutex
	newRequestArgsForCall []struct {
		arg1 *client.Operation
	}
	newRequestReturns struct {
		result1 *client.Request
	}
	newRequestReturnsOnCall map[int]struct {
		result1 *client.Request
	}
	WithAuthTokenStub        func(string) client.SessionClient
	withAuthTokenMutex       sync.RWMutex
	withAuthTokenArgsForCall []struct {
		arg1 string
	}
	withAuthTokenReturns struct {
		result1 client.SessionClient
	}
	withAuthTokenReturnsOnCall map[int]struct {
		result1 client.SessionClient
	}
	WithDebugStub        func(io.Writer) client.SessionClient
	withDebugMutex       sync.RWMutex
	withDebugArgsForCall []struct {
		arg1 io.Writer
	}
	withDebugReturns struct {
		result1 client.SessionClient
	}
	withDebugReturnsOnCall map[int]struct {
		result1 client.SessionClient
	}
	WithPathParameterStub        func(string, string) client.SessionClient
	withPathParameterMutex       sync.RWMutex
	withPathParameterArgsForCall []struct {
		arg1 string
		arg2 string
	}
	withPathParameterReturns struct {
		result1 client.SessionClient
	}
	withPathParameterReturnsOnCall map[int]struct {
		result1 client.SessionClient
	}
	WithQueryValueStub        func(string, string) client.SessionClient
	withQueryValueMutex       sync.RWMutex
	withQueryValueArgsForCall []struct {
		arg1 string
		arg2 string
	}
	withQueryValueReturns struct {
		result1 client.SessionClient
	}
	withQueryValueReturnsOnCall map[int]struct {
		result1 client.SessionClient
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *SessionClient) NewRequest(arg1 *client.Operation) *client.Request {
	fake.newRequestMutex.Lock()
	ret, specificReturn := fake.newRequestReturnsOnCall[len(fake.newRequestArgsForCall)]
	fake.newRequestArgsForCall = append(fake.newRequestArgsForCall, struct {
		arg1 *client.Operation
	}{arg1})
	fake.recordInvocation("NewRequest", []interface{}{arg1})
	fake.newRequestMutex.Unlock()
	if fake.NewRequestStub != nil {
		return fake.NewRequestStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.newRequestReturns
	return fakeReturns.result1
}

func (fake *SessionClient) NewRequestCallCount() int {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	return len(fake.newRequestArgsForCall)
}

func (fake *SessionClient) NewRequestCalls(stub func(*client.Operation) *client.Request) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = stub
}

func (fake *SessionClient) NewRequestArgsForCall(i int) *client.Operation {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	argsForCall := fake.newRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *SessionClient) NewRequestReturns(result1 *client.Request) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = nil
	fake.newRequestReturns = struct {
		result1 *client.Request
	}{result1}
}

func (fake *SessionClient) NewRequestReturnsOnCall(i int, result1 *client.Request) {
	fake.newRequestMutex.Lock()
	defer fake.newRequestMutex.Unlock()
	fake.NewRequestStub = nil
	if fake.newRequestReturnsOnCall == nil {
		fake.newRequestReturnsOnCall = make(map[int]struct {
			result1 *client.Request
		})
	}
	fake.newRequestReturnsOnCall[i] = struct {
		result1 *client.Request
	}{result1}
}

func (fake *SessionClient) WithAuthToken(arg1 string) client.SessionClient {
	fake.withAuthTokenMutex.Lock()
	ret, specificReturn := fake.withAuthTokenReturnsOnCall[len(fake.withAuthTokenArgsForCall)]
	fake.withAuthTokenArgsForCall = append(fake.withAuthTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WithAuthToken", []interface{}{arg1})
	fake.withAuthTokenMutex.Unlock()
	if fake.WithAuthTokenStub != nil {
		return fake.WithAuthTokenStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withAuthTokenReturns
	return fakeReturns.result1
}

func (fake *SessionClient) WithAuthTokenCallCount() int {
	fake.withAuthTokenMutex.RLock()
	defer fake.withAuthTokenMutex.RUnlock()
	return len(fake.withAuthTokenArgsForCall)
}

func (fake *SessionClient) WithAuthTokenCalls(stub func(string) client.SessionClient) {
	fake.withAuthTokenMutex.Lock()
	defer fake.withAuthTokenMutex.Unlock()
	fake.WithAuthTokenStub = stub
}

func (fake *SessionClient) WithAuthTokenArgsForCall(i int) string {
	fake.withAuthTokenMutex.RLock()
	defer fake.withAuthTokenMutex.RUnlock()
	argsForCall := fake.withAuthTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *SessionClient) WithAuthTokenReturns(result1 client.SessionClient) {
	fake.withAuthTokenMutex.Lock()
	defer fake.withAuthTokenMutex.Unlock()
	fake.WithAuthTokenStub = nil
	fake.withAuthTokenReturns = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithAuthTokenReturnsOnCall(i int, result1 client.SessionClient) {
	fake.withAuthTokenMutex.Lock()
	defer fake.withAuthTokenMutex.Unlock()
	fake.WithAuthTokenStub = nil
	if fake.withAuthTokenReturnsOnCall == nil {
		fake.withAuthTokenReturnsOnCall = make(map[int]struct {
			result1 client.SessionClient
		})
	}
	fake.withAuthTokenReturnsOnCall[i] = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithDebug(arg1 io.Writer) client.SessionClient {
	fake.withDebugMutex.Lock()
	ret, specificReturn := fake.withDebugReturnsOnCall[len(fake.withDebugArgsForCall)]
	fake.withDebugArgsForCall = append(fake.withDebugArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.recordInvocation("WithDebug", []interface{}{arg1})
	fake.withDebugMutex.Unlock()
	if fake.WithDebugStub != nil {
		return fake.WithDebugStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withDebugReturns
	return fakeReturns.result1
}

func (fake *SessionClient) WithDebugCallCount() int {
	fake.withDebugMutex.RLock()
	defer fake.withDebugMutex.RUnlock()
	return len(fake.withDebugArgsForCall)
}

func (fake *SessionClient) WithDebugCalls(stub func(io.Writer) client.SessionClient) {
	fake.withDebugMutex.Lock()
	defer fake.withDebugMutex.Unlock()
	fake.WithDebugStub = stub
}

func (fake *SessionClient) WithDebugArgsForCall(i int) io.Writer {
	fake.withDebugMutex.RLock()
	defer fake.withDebugMutex.RUnlock()
	argsForCall := fake.withDebugArgsForCall[i]
	return argsForCall.arg1
}

func (fake *SessionClient) WithDebugReturns(result1 client.SessionClient) {
	fake.withDebugMutex.Lock()
	defer fake.withDebugMutex.Unlock()
	fake.WithDebugStub = nil
	fake.withDebugReturns = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithDebugReturnsOnCall(i int, result1 client.SessionClient) {
	fake.withDebugMutex.Lock()
	defer fake.withDebugMutex.Unlock()
	fake.WithDebugStub = nil
	if fake.withDebugReturnsOnCall == nil {
		fake.withDebugReturnsOnCall = make(map[int]struct {
			result1 client.SessionClient
		})
	}
	fake.withDebugReturnsOnCall[i] = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithPathParameter(arg1 string, arg2 string) client.SessionClient {
	fake.withPathParameterMutex.Lock()
	ret, specificReturn := fake.withPathParameterReturnsOnCall[len(fake.withPathParameterArgsForCall)]
	fake.withPathParameterArgsForCall = append(fake.withPathParameterArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("WithPathParameter", []interface{}{arg1, arg2})
	fake.withPathParameterMutex.Unlock()
	if fake.WithPathParameterStub != nil {
		return fake.WithPathParameterStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withPathParameterReturns
	return fakeReturns.result1
}

func (fake *SessionClient) WithPathParameterCallCount() int {
	fake.withPathParameterMutex.RLock()
	defer fake.withPathParameterMutex.RUnlock()
	return len(fake.withPathParameterArgsForCall)
}

func (fake *SessionClient) WithPathParameterCalls(stub func(string, string) client.SessionClient) {
	fake.withPathParameterMutex.Lock()
	defer fake.withPathParameterMutex.Unlock()
	fake.WithPathParameterStub = stub
}

func (fake *SessionClient) WithPathParameterArgsForCall(i int) (string, string) {
	fake.withPathParameterMutex.RLock()
	defer fake.withPathParameterMutex.RUnlock()
	argsForCall := fake.withPathParameterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *SessionClient) WithPathParameterReturns(result1 client.SessionClient) {
	fake.withPathParameterMutex.Lock()
	defer fake.withPathParameterMutex.Unlock()
	fake.WithPathParameterStub = nil
	fake.withPathParameterReturns = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithPathParameterReturnsOnCall(i int, result1 client.SessionClient) {
	fake.withPathParameterMutex.Lock()
	defer fake.withPathParameterMutex.Unlock()
	fake.WithPathParameterStub = nil
	if fake.withPathParameterReturnsOnCall == nil {
		fake.withPathParameterReturnsOnCall = make(map[int]struct {
			result1 client.SessionClient
		})
	}
	fake.withPathParameterReturnsOnCall[i] = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithQueryValue(arg1 string, arg2 string) client.SessionClient {
	fake.withQueryValueMutex.Lock()
	ret, specificReturn := fake.withQueryValueReturnsOnCall[len(fake.withQueryValueArgsForCall)]
	fake.withQueryValueArgsForCall = append(fake.withQueryValueArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("WithQueryValue", []interface{}{arg1, arg2})
	fake.withQueryValueMutex.Unlock()
	if fake.WithQueryValueStub != nil {
		return fake.WithQueryValueStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withQueryValueReturns
	return fakeReturns.result1
}

func (fake *SessionClient) WithQueryValueCallCount() int {
	fake.withQueryValueMutex.RLock()
	defer fake.withQueryValueMutex.RUnlock()
	return len(fake.withQueryValueArgsForCall)
}

func (fake *SessionClient) WithQueryValueCalls(stub func(string, string) client.SessionClient) {
	fake.withQueryValueMutex.Lock()
	defer fake.withQueryValueMutex.Unlock()
	fake.WithQueryValueStub = stub
}

func (fake *SessionClient) WithQueryValueArgsForCall(i int) (string, string) {
	fake.withQueryValueMutex.RLock()
	defer fake.withQueryValueMutex.RUnlock()
	argsForCall := fake.withQueryValueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *SessionClient) WithQueryValueReturns(result1 client.SessionClient) {
	fake.withQueryValueMutex.Lock()
	defer fake.withQueryValueMutex.Unlock()
	fake.WithQueryValueStub = nil
	fake.withQueryValueReturns = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithQueryValueReturnsOnCall(i int, result1 client.SessionClient) {
	fake.withQueryValueMutex.Lock()
	defer fake.withQueryValueMutex.Unlock()
	fake.WithQueryValueStub = nil
	if fake.withQueryValueReturnsOnCall == nil {
		fake.withQueryValueReturnsOnCall = make(map[int]struct {
			result1 client.SessionClient
		})
	}
	fake.withQueryValueReturnsOnCall[i] = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	fake.withAuthTokenMutex.RLock()
	defer fake.withAuthTokenMutex.RUnlock()
	fake.withDebugMutex.RLock()
	defer fake.withDebugMutex.RUnlock()
	fake.withPathParameterMutex.RLock()
	defer fake.withPathParameterMutex.RUnlock()
	fake.withQueryValueMutex.RLock()
	defer fake.withQueryValueMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *SessionClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.SessionClient = new(SessionClient)
